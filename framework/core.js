const hookStorage = new Map();
let currentComponent = null;
let __previousVDOM__ = null;
let __lastDom__ = null
// had l function kachd lia l VDOM mn 3and l user wkatkhdm hia b DOm bach trj3o real DOM
function createRealElement(element) {
  if (element.tag === 'text') {
    return document.createTextNode(element.value || '');
  }
  const newElement = document.createElement(element.tag) // there is a special tag = text rdi balk mno mn ba3d :)
  // const HTMLevents = [] //binma 3raft ach khas ydar bihoum wsafi

  // const newElement = []
  // let listners = []
  if (element.attrs && Object.keys(element.attrs).length > 0) {
    newElement.__listeners__ = [];
    for (const attribute in element.attrs) {
      if (element.attrs.hasOwnProperty(attribute)) {
        if (attribute.startsWith("on")) {
          newElement.attribute = element.attrs[attribute]
          // HTMLevents.push(element.attrs[attribute])
        } else if (attribute.startsWith("$")) {
          const event = attribute.slice(1)
          const func = element.attrs[attribute]
          if (typeof func === 'function') {
            newElement.addEventListener(event, func)
            newElement.__listeners__.push({
              type: event,
              handler: func
            });
          } else {
            console.error(`Handler for event ${attribute} is not a function.`);
          }
        } else if (attribute == 'className') {
          newElement.setAttribute('class', element.attrs[attribute])
        } else {
          newElement.setAttribute(attribute, element.attrs[attribute])
        }
      }
    }
  }
  if (element.children == undefined || element.children.length == 0) {
    return newElement
  }

  element.children.forEach(node => {
    if (!node) return;
    const realChild = createRealElement(node)
    // if (realChild != undefined){
    newElement.appendChild(realChild)
    // newElement.push(realChild)
    // }
  });
  return newElement
}

function runComponent(componentFunction) {
  // currentComponent = componentFunction

  if (!hookStorage.has(componentFunction)) {
    hookStorage.set(componentFunction, [])
    hookStorage.get(componentFunction)[0] = 1
  }
  console.log(222);
  hookStorage.get(componentFunction)[0] = 1

  // componentFunction.stateIndex = 0
  const VDOM = componentFunction()

  // currentComponent = null;
  return VDOM
}

function render(componentFunction, rootContainer) {
  const oldDOM = __lastDom__
  currentComponent = componentFunction


  const newVDOM = runComponent(componentFunction);
  console.log(33);
  console.log("Old Doom :", oldDOM);

  if (oldDOM) {
    // unmount(oldDOM)
    // rootContainer.removeChild(oldDOM)
    __lastDom__ = updateDom(__previousVDOM__, newVDOM, oldDOM);
  } else {
    const newDom = createRealElement(newVDOM)
    rootContainer.appendChild(newDom)
    __lastDom__ = newDom
  }
  __previousVDOM__ = newVDOM;
}

function unmount(oldDOM) {
  if (oldDOM.__listeners__) {
    const listenersToRemove = oldDOM.__listeners__;

    listenersToRemove.forEach(listener => {
      oldDOM.removeEventListener(listener.type, listener.handler);
    });

    delete oldDOM.__listeners__;
  }

  const children = oldDOM.children
  for (let i = 0; i < children.length; i++) {
    const child = children[i]
    unmount(child)
  }
}

// let currentComponent = null;
function useState(initialValue) {
  const value = hookStorage.get(currentComponent);

  const temp = hookStorage.get(currentComponent)
  const currentIndex = temp[0]

  //set that value f blasthaa
  if (hookStorage.get(currentComponent)[currentIndex] === undefined) {
    hookStorage.get(currentComponent)[currentIndex] = initialValue
  }

  //setValue
  const setterFunc = (newValue) => {
    hookStorage.get(currentComponent)[currentIndex] = newValue

    //Call re-render
    // render()
  }

  hookStorage.get(currentComponent)[0]++
  return [hookStorage.get(currentComponent)[currentIndex], setterFunc]
}

function useRoute() {
  const getPath = () => window.location.hash.slice(1) || '/';
  const [path, setPath] = useState(getPath());

  if (!window.__hash_listener__) {
    window.__hash_listener__ = true;
    window.addEventListener('hashchange', () => {
      // Update the state to trigger re-render
      setPath(getPath());
    });
  }
  return path;
}


function Router({ routes }) {
  const currentPath = useRoute();

  // Look up the component based on the path, default to a 404
  const ComponentToRender = routes[currentPath] || routes['/404'];

  if (ComponentToRender) {
    // Return the VDOM generated by the matched component function
    return createRealElement(ComponentToRender, null);
  }

  // Should be caught by the 404 route, but for safety:
  return createRealElement('div', { className: 'text-red-500 font-bold' }, 'Router Error: Component not found.');
}

function updateDom(oldVDOM, newVDOM, realElement) {
  // âœ… Handle text nodes
  if (newVDOM.tag === 'text') {
    if (oldVDOM.tag === 'text') {
      // Both are text nodes - just update the text content if different
      if (oldVDOM.value !== newVDOM.value) {
        realElement.textContent = newVDOM.value;
      }
      return realElement;
    } else {
      // Old was element, new is text - replace it
      const newTextNode = document.createTextNode(newVDOM.value || '');
      realElement.replaceWith(newTextNode);
      return newTextNode;
    }
  }

  // âœ… Handle case where old was text but new is element
  if (oldVDOM.tag === 'text' && newVDOM.tag !== 'text') {
    const newRealElement = createRealElement(newVDOM);
    realElement.replaceWith(newRealElement);
    return newRealElement;
  }

  // Original code continues...
  if (newVDOM.tag != oldVDOM.tag) {
    const newRealElement = createRealElement(newVDOM)
    realElement.replaceWith(newRealElement);
    return newRealElement
  }

  updateAttributes(realElement, oldVDOM.attrs, newVDOM.attrs)

  const realChildren = Array.from(realElement.childNodes)
  const oldChildren = oldVDOM.children || [];
  const newChildren = newVDOM.children || [];
  const maxLen = Math.max(oldChildren.length, newChildren.length)

  for (let i = 0; i < maxLen; i++) {
    const oldChild = oldChildren[i]
    const newChild = newChildren[i]
    const realChild = realChildren[i]

    // CaseA: Both exist
    if (newChild && oldChild) {
      updateDom(oldChild, newChild, realChild)
    }
    // CaseB: New Child Added
    else if (newChild && !oldChild) {
      const newChildElement = createRealElement(newChild)
      realElement.appendChild(newChildElement)
    }
    // CaseC: Old Child Removed (Unmount)
    else if (!newChild && oldChild) {
      realElement.removeChild(realChild)
    }
  }
  return realElement
}

function updateAttributes(oldDOM, oldAttributes, newAttributes) {
  oldAttributes = oldAttributes || {}
  newAttributes = newAttributes || {}
  //Loop1 : tl9a ri l elements li tmes7ou
  for (const oldKey of Object.keys(oldAttributes)) {
    if (!(oldKey in newAttributes)) {
      if (oldKey.startsWith('$')) {
        const eventType = oldKey.toLowerCase().substring(1)
        oldDOM.removeEventListener(eventType, oldAttributes[oldKey]);
      } else {
        oldDOM.removeAttribute(oldKey)
      }
    }
  }

  //Loop2 : t handle l add w modify
  for (const newKey in newAttributes) {
    const oldValue = oldAttributes[newKey]
    const newValue = newAttributes[newKey]

    if (oldValue != newValue) {
      if (newKey.startsWith("$")) {
        const event = newKey.slice(1)
        const func = newValue
        if (typeof func === 'function') {
          if (oldValue) {
            oldDOM.removeEventListener(event, oldValue);
          }
          oldDOM.addEventListener(event, func)
          oldDOM.__listeners__.push({
            type: event,
            handler: func
          });
        } else {
          console.error(`Handler for event ${key} is not a function.`);
        }
      } else if (newKey == 'className') {
        oldDOM.setAttribute('class', newValue)
      } else {
        oldDOM.setAttribute(newKey, newValue)
      }
    }

  }
}

function TodoApp() {
  const [todos, setTodos] = useState([]);
  const path = useRoute(); // "/", "/active", "/completed"

  function filteredTodos() {
    if (path === "/active") return todos.filter(t => !t.completed);
    if (path === "/completed") return todos.filter(t => t.completed);
    return todos;
  }

  function addTodo(e) {
    if (e.key === "Enter" && e.target.value.trim() !== "") {
      setTodos([
        ...todos,
        {
          id: Date.now(),
          text: e.target.value.trim(),
          completed: false,
          editing: false
        }
      ]);
      e.target.value = "";
      render(TodoApp, document.getElementById("root-app"));
    }
  }

  function toggleTodo(id) {
    setTodos(
      todos.map(t => t.id === id ? { ...t, completed: !t.completed } : t)
    );
    render(TodoApp, document.getElementById("root-app"));
  }

  function deleteTodo(id) {
    setTodos(todos.filter(t => t.id !== id));
    render(TodoApp, document.getElementById("root-app"));
  }

  function startEditing(id) {
    setTodos(
      todos.map(t => t.id === id ? { ...t, editing: true } : t)
    );
    render(TodoApp, document.getElementById("root-app"));
  }

  function updateTodoText(e, id) {
    if (e.key === "Enter") {
      const newText = e.target.value.trim();
      setTodos(
        todos.map(t => t.id === id ? { ...t, text: newText, editing: false } : t)
      );
      render(TodoApp, document.getElementById("root-app"));
    }
  }

  function blurEdit(e, id) {
    const newText = e.target.value.trim();
    setTodos(
      todos.map(t => t.id === id ? { ...t, text: newText, editing: false } : t)
    );
    render(TodoApp, document.getElementById("root-app"));
  }

  function clearCompleted() {
    setTodos(todos.filter(t => !t.completed));
    render(TodoApp, document.getElementById("root-app"));
  }

  function toggleAll() {
    const allCompleted = todos.every(t => t.completed);
    setTodos(todos.map(t => ({ ...t, completed: !allCompleted })));
    render(TodoApp, document.getElementById("root-app"));
  }

  // ================================================================
  //  ðŸ§± RETURN THE VDOM (THE REAL ANSWER YOU REQUESTED)
  // ================================================================
  return {
    tag: "section",
    attrs: { className: "todoapp" },
    children: [
      /* HEADER */
      {
        tag: "header",
        attrs: { className: "header" },
        children: [
          { tag: "h1", children: [{ tag: "text", value: "todos" }] },
          {
            tag: "input",
            attrs: {
              className: "new-todo",
              placeholder: "What needs to be done?",
              autofocus: "",
              $keypress: addTodo
            }
          }
        ]
      },

      /* MAIN */
      {
        tag: "section",
        attrs: { className: "main" },
        children: [
          {
            tag: "input",
            attrs: {
              id: "toggle-all",
              className: "toggle-all",
              type: "checkbox",
              $click: toggleAll
            }
          },
          {
            tag: "label",
            attrs: { for: "toggle-all", className: "toggle-all-label" }
          },

          {
            tag: "ul",
            attrs: { className: "todo-list" },
            children: filteredTodos().map(todo => ({
              tag: "li",
              attrs: {
                className:
                  (todo.completed ? "completed " : "") +
                  (todo.editing ? "editing" : ""),
                "data-id": todo.id
              },
              children: [
                /* VIEW */
                {
                  tag: "div",
                  attrs: { className: "view" },
                  children: [
                    {
                      tag: "input",
                      attrs: {
                        className: "toggle",
                        type: "checkbox",
                        checked: todo.completed ? "checked" : null,
                        $click: () => toggleTodo(todo.id)
                      }
                    },
                    {
                      tag: "label",
                      attrs: {
                        $dblclick: () => startEditing(todo.id)
                      },
                      children: [{ tag: "text", value: todo.text }]
                    },
                    {
                      tag: "button",
                      attrs: {
                        className: "destroy",
                        $click: () => deleteTodo(todo.id)
                      }
                    }
                  ]
                },

                /* EDIT INPUT */
                {
                  tag: "input",
                  attrs: {
                    className: "edit",
                    value: todo.text,
                    $keypress: (e) => updateTodoText(e, todo.id),
                    $blur: (e) => blurEdit(e, todo.id)
                  }
                }
              ]
            }))
          }
        ]
      },

      /* FOOTER */
      todos.length > 0
        ? {
          tag: "footer",
          attrs: { className: "footer" },
          children: [
            {
              tag: "span",
              attrs: { className: "todo-count" },
              children: [
                { tag: "strong", children: [{ tag: "text", value: todos.filter(t => !t.completed).length }] },
                { tag: "text", value: " items left" }
              ]
            },

            /* FILTERS */
            {
              tag: "ul",
              attrs: { className: "filters" },
              children: [
                filterLink("/", "All", path),
                filterLink("/active", "Active", path),
                filterLink("/completed", "Completed", path)
              ]
            },

            /* CLEAR COMPLETED */
            {
              tag: "button",
              attrs: {
                className: "clear-completed",
                $click: clearCompleted
              },
              children: [{ tag: "text", value: "Clear completed" }]
            }
          ]
        }
        : null
    ]
  };
}

/* helper: filter links */
function filterLink(target, text, current) {
  return {
    tag: "li",
    children: [
      {
        tag: "a",
        attrs: {
          href: `#${target}`,
          className: current === target ? "selected" : ""
        },
        children: [{ tag: "text", value: text }]
      }
    ]
  };
}


const root = document.getElementById('app-root')
render(TodoApp, root)
